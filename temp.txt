#include "recording.h"
#include <iostream>
#include <filesystem>
#include <fstream>
#include <vector>
#include "portaudio.h"

namespace fs = std::filesystem;

constexpr int SAMPLE_RATE = 44100;
constexpr int FRAMES_PER_BUFFER = 256;
constexpr PaSampleFormat SAMPLE_FORMAT = paInt16; // 16-bit PCM

struct RecordingData {
    std::vector<int16_t> samples;
    bool recording = false;
};

static int recordCallback(
    const void *inputBuffer, void *outputBuffer,
    unsigned long framesPerBuffer,
    const PaStreamCallbackTimeInfo* timeInfo,
    PaStreamCallbackFlags statusFlags,
    void *userData )
{
    auto *data = (RecordingData*)userData;
    if (inputBuffer && data->recording) {
        const int16_t *in = (const int16_t*)inputBuffer;
        data->samples.insert(data->samples.end(), in, in + framesPerBuffer);
    }
    return paContinue;
}

static void writeWav(const std::string &filename, const std::vector<int16_t>& samples) {
    std::ofstream out(filename, std::ios::binary);

    int sampleRate = SAMPLE_RATE;
    int bitsPerSample = 16;
    int numChannels = 1;
    int byteRate = sampleRate * numChannels * bitsPerSample/8;
    int blockAlign = numChannels * bitsPerSample/8;
    int subchunk2Size = samples.size() * numChannels * bitsPerSample/8;
    int chunkSize = 36 + subchunk2Size;

    out.write("RIFF", 4);
    out.write((char*)&chunkSize, 4);
    out.write("WAVE", 4);

    out.write("fmt ", 4);
    int subchunk1Size = 16;
    short audioFormat = 1;
    out.write((char*)&subchunk1Size, 4);
    out.write((char*)&audioFormat, 2);
    out.write((char*)&numChannels, 2);
    out.write((char*)&sampleRate, 4);
    out.write((char*)&byteRate, 4);
    out.write((char*)&blockAlign, 2);
    out.write((char*)&bitsPerSample, 2);

    out.write("data", 4);
    out.write((char*)&subchunk2Size, 4);
    out.write((char*)samples.data(), samples.size()*sizeof(int16_t));
}

void recordAudio(const std::string &label) {
    fs::create_directories("Recordings/" + label);

    int fileIndex = 1;
    for (auto& p : fs::directory_iterator("Recordings/" + label)) {
        if (p.path().extension() == ".wav") {
            int n = std::stoi(p.path().stem().string());
            if (n >= fileIndex) fileIndex = n+1;
        }
    }
    std::string filename = "Recordings/" + label + "/" + std::to_string(fileIndex) + ".wav";

    Pa_Initialize();
    RecordingData data;
    data.recording = false;

    PaStream *stream;
    Pa_OpenDefaultStream(&stream, 1, 0, SAMPLE_FORMAT, SAMPLE_RATE,
                         FRAMES_PER_BUFFER, recordCallback, &data);

    Pa_StartStream(stream);

    std::cout << "Press ENTER to start recording...\n";
    std::cin.get();
    data.recording = true;
    std::cout << "Recording... Press ENTER again to stop.\n";
    std::cin.get();
    data.recording = false;

    Pa_StopStream(stream);
    Pa_CloseStream(stream);
    Pa_Terminate();

    writeWav(filename, data.samples);
    std::cout << "Saved recording to " << filename << "\n";
}
